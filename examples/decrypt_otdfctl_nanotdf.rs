//! Decrypt a NanoTDF file created by otdfctl
//!
//! This tests if our Rust implementation can decrypt Go-created NanoTDF files

use opentdf_crypto::tdf::nanotdf::NanoTdf;
use std::fs;

fn main() {
    println!("=== Decrypt otdfctl-created NanoTDF ===\n");

    // Read the NanoTDF file created by otdfctl
    let filename = "/tmp/test-otdfctl-created.nanotdf.tdf";
    let nanotdf_bytes =
        fs::read(filename).expect("Failed to read NanoTDF file - create it with otdfctl first");

    println!("1. File size: {} bytes", nanotdf_bytes.len());

    // Parse the NanoTDF
    println!("\n2. Parsing NanoTDF header...");
    let nanotdf = match NanoTdf::from_bytes(&nanotdf_bytes) {
        Ok(n) => {
            println!("   ✓ Header parsed successfully");
            n
        }
        Err(e) => {
            eprintln!("   ✗ Failed to parse: {}", e);
            return;
        }
    };

    // Show header info
    println!("\n3. Header Information:");
    println!("   KAS URL: (from header)");
    println!("   ECC Mode: (from header)");
    println!("   Policy type: (from header)");
    println!(
        "   Ephemeral key size: {} bytes",
        nanotdf.header.ephemeral_public_key.len()
    );

    // For this test, we can't decrypt without the private key
    // The file was encrypted with otdfctl's ephemeral keypair
    // We don't have the ephemeral private key

    println!("\n4. Decryption Test:");
    println!("   Note: We cannot decrypt this file without:");
    println!("   - The ephemeral private key (generated by otdfctl)");
    println!("   - OR KAS rewrap (which requires KAS integration)");
    println!("\n   This test confirms we can:");
    println!("   ✓ Parse otdfctl-created NanoTDF headers");
    println!("   ✓ Read the binary format");
    println!("\n   Next: Implement KAS rewrap to actually decrypt");

    // Show what we successfully parsed
    println!("\n5. Successfully Parsed:");
    println!("   ✓ Magic number and version");
    println!("   ✓ Resource locator (KAS URL + KID)");
    println!("   ✓ ECC and binding mode");
    println!("   ✓ Symmetric cipher configuration");
    println!("   ✓ Policy (type and content)");
    println!("   ✓ Policy binding");
    println!("   ✓ Ephemeral public key");
    println!("   ✓ Payload (length, IV, ciphertext+tag)");
}
